<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>SCADA Temperaturas</title>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.1.0/paho-mqtt.min.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.js" type="text/javascript"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <style>
        body {
            font-family: 'Consolas', monospace;
            background-color: #1e1e2f;
            color: #eee;
            margin: 20px;
        }

        h1 {
            color: #00ffff;
            text-align: center;
            margin-bottom: 30px;
            letter-spacing: 1px;
        }

        #dashboard {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 50px;
        }

        .card {
            background-color: #2c2c3e;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        #ultimoValor {
            font-size: 1.5em;
            margin-bottom: 15px;
        }


        #grafico {
            width: 100% !important;
            height: 100% !important;

        }
    </style>
</head>

<body>
    <div class="card">
        <div id="ultimo">Cargando último valor...</div>
        <canvas id="gauge" width="300" height="150"></canvas>
    </div>

    <div class="card">
        <h3>Punto Inicial</h3>
        <label>Fecha: <input type="datetime-local" id="inputFechaInicio"></label>
        <label>Temperatura: <input type="number" id="inputTempInicio" step="0.1"></label>
        <h3>Punto Final</h3>
        <label>Fecha: <input type="datetime-local" id="inputFechaFin"></label>
        <label>Temperatura: <input type="number" id="inputTempFin" step="0.1"></label>
        <div>
            <hr>
            <button class="btn" onclick="analizarDatos()">ANALIZAR 1o</button>
            <button class="btn" onclick="analizarDatos2()">ANALIZAR 2o</button>
        </div>
        <h1>
            <div id="formula"></div>
        </h1>
    </div>

    <div class="card">
        <canvas id="grafico"></canvas>
    </div>


    <div class="card">
        <div>
            <span>Salida 1</span>
            <button id="btnEncender">Encender</button>
            <button id="btnApagar">Apagar</button>
        </div>
        <div>
              <span>Salida 2</span>
            <button id="btnEncender2">Encender</button>
            <button id="btnApagar2">Apagar</button>
        </div>

        <div>
            <form action="/api/clean" method="POST">
                <button id="btnClear">Limpiar BBDD</button>
            </form>
        </div>
    </div>
    <script>
        // =========================
        // UTILIDADES
        // =========================
        async function fetchDatos(endpoint) {
            try {
                const res = await fetch(`/api/${endpoint}`);
                if (!res.ok) throw new Error(`Error al obtener ${endpoint}: ${res.status}`);
                return await res.json();
            } catch (error) {
                console.error(error);
                return null;
            }
        }

        function formatearFecha(fechaStr) {
            const f = new Date(fechaStr);
            const dia = f.getDate().toString().padStart(2, '0');
            const mes = (f.getMonth() + 1).toString().padStart(2, '0');
            const anio = f.getFullYear();
            const horas = f.getHours().toString().padStart(2, '0');
            const minutos = f.getMinutes().toString().padStart(2, '0');
            const segundos = f.getSeconds().toString().padStart(2, '0');
            return `${dia}/${mes}/${anio} ${horas}:${minutos}:${segundos}`;
        }
        function formatearHora(fechaStr) {
            const f = new Date(fechaStr);
            return `${f.getHours().toString().padStart(2, '0')}:${f.getMinutes().toString().padStart(2, '0')}:${f.getSeconds().toString().padStart(2, '0')}`;
        }

        function generarSistemaSegundoOrden({
            puntos = 500,
            dt = 0.1,               // paso temporal (segundos)
            zeta = 0.5,             // amortiguamiento (<1 subamortiguado)
            omegaN = 1,             // frecuencia natural
            fechaInicio = new Date()
        } = {}) {
            const datos = [];
            const omegaD = omegaN * Math.sqrt(1 - zeta * zeta);

            for (let i = 0; i < puntos; i++) {
                const t = i * dt;

                const lectura = 30 * (
                    1 -
                    Math.exp(-zeta * omegaN * t) *
                    (
                        Math.cos(omegaD * t) +
                        (zeta / Math.sqrt(1 - zeta * zeta)) * Math.sin(omegaD * t)
                    ));

                datos.push({
                    fecha: new Date(fechaInicio.getTime() + t * 1000),
                    lectura
                });
            }

            return datos;
        }

        function findMaximos(array) {
            const maximos = [];
            const minimos = [];
            if ((array[array.length - 1].lectura - array[0].lectura) > 0) {
                // teniendo en cuenta 3 valores por delante y 3 por detras
                for (let i = 5; i < array.length - 5; i++) {
                    if (array[i].lectura > array[i - 3].lectura && array[i].lectura > array[i - 2].lectura && array[i].lectura > array[i - 1].lectura && array[i].lectura > array[i + 1].lectura && array[i].lectura > array[i + 2].lectura && array[i].lectura > array[i + 3].lectura) {
                        maximos.push({
                            index: i,
                            lectura: array[i].lectura,
                            fecha: new Date(array[i].fecha)
                        });
                    }
                }
                return maximos;
            } else {
                // teniendo en cuenta 3 valores por delante y 3 por detras
                for (let i = 5; i < array.length - 5; i++) {
                    if (array[i].lectura < array[i - 3].lectura && array[i].lectura < array[i - 2].lectura && array[i].lectura < array[i - 1].lectura && array[i].lectura < array[i + 1].lectura && array[i].lectura < array[i + 2].lectura && array[i].lectura < array[i + 3].lectura) {
                        minimos.push({
                            index: i,
                            lectura: array[i].lectura,
                            fecha: new Date(array[i].fecha)
                        });
                    }
                }
                return minimos;
            }
        }
        function valorMedio(array) {
            let suma = 0;
            for (let i = 0; i < array.length - 1; i++) {
                suma += array[i].lectura;
            }
            return suma / array.length;
        }
        function tiempoSubida(arrayFiltrados, valorFinal) {
            //tiempo de subida
            if ((arrayFiltrados[arrayFiltrados.length - 1].lectura - arrayFiltrados[0].lectura) > 0) {
                for (let i = 0; i < arrayFiltrados.length - 1; i++) {
                    if (arrayFiltrados[i].lectura > valorFinal)
                        return (new Date(arrayFiltrados[i].fecha) - new Date(arrayFiltrados[0].fecha)) / 1000;
                    //return (new Date(arrayFiltrados[i].fecha) - new Date(arrayFiltrados[0].fecha)) / 810;
                }
                //o tiempo de bajada
            } else {
                for (let i = 0; i < arrayFiltrados.length - 1; i++) {
                    if (arrayFiltrados[i].lectura < valorFinal)
                        return (new Date(arrayFiltrados[i].fecha) - new Date(arrayFiltrados[0].fecha)) / 1000;
                    //return (new Date(arrayFiltrados[i].fecha) - new Date(arrayFiltrados[0].fecha)) / 810;
                }
            }
        }
        function analizarDatos2() {
            var inputFechaInicio = new Date(document.getElementById("inputFechaInicio").value + ":00Z");
            var inputTempInicio = document.getElementById("inputTempInicio").value;
            var inputFechaFin = new Date(document.getElementById("inputFechaFin").value + ":00Z");
            var inputTempFin = document.getElementById("inputTempFin").value;
            //console.log(inputFechaInicio + " " + inputFechaFin);
            //console.log(inputFechaFin + " " + inputTempFin);

            var filtrados = datos.filter(item => {
                const fechaItem = new Date(item.fecha);
                return fechaItem >= inputFechaInicio && fechaItem <= inputFechaFin;
            });

            //===========================
            //VALORES PRUEBA
            /*         filtrados = generarSistemaSegundoOrden({
                        puntos: 500,
                        dt: 0.05,
                        zeta: 0.5,
                        omegaN: 1.5
                    }); */
            // omegaP=1.5*raiz(1-0.5^2)=1.299
            //T=4.83
            //SIGMA=0.75
            //tiempoS=2.033558625
            //tiempoP=2.41
            //tecta=0.5
            //===========================

            //Obtenemos los maximos valores
            var maximos = findMaximos(filtrados);
            // Para poder analizarlo como segundo orden debe haber al menos 2 maximos, si no, no puede hacerse
            if (maximos.length < 2) {
                document.getElementById("formula").innerHTML = "Imposible modelar como segundo orden con los datos seleccionados"
            } else {
                // Ahora filtramos desde el segundo maximo(asegurando que exista), para luego calcular la media de estos valores como valor final
                var ultimos = filtrados.filter(item => {
                    const fechaItem = new Date(item.fecha);
                    if (maximos.length > 1) {
                        return fechaItem >= maximos[1].fecha;
                    }
                    else {
                        return fechaItem >= maximos[0].fecha;
                    }
                });
                console.log(filtrados);
                console.log(maximos);
                console.log(ultimos);
                var valorFinal = valorMedio(ultimos);
                var periodo = (maximos[1].fecha - maximos[0].fecha) / 1000;
                var omegaP = 2 * Math.PI / periodo;

                var tiempoP = (maximos[0].fecha - new Date(filtrados[0].fecha)) / 1000;
                var tiempoS = tiempoSubida(filtrados, valorFinal);
                //tiempo de subida  ts=(pi-tecta)/omegaP
                var tecta = Math.PI - tiempoS * omegaP;
                var dseta = Math.cos(tecta);
                var omegaN = omegaP / (Math.sqrt(1 - dseta ^ 2));

                //Ahora tiempo de establecimiento
                console.log("Valor final: " + valorFinal);
                console.log("Periodo: " + periodo);
                console.log("omegaP: " + omegaP);
                console.log("tiempoP: " + tiempoP);
                console.log("tiempoS: " + tiempoS);
                console.log("tecta: " + tecta + "  dseta: " + dseta);
                const K = (valorFinal / filtrados[0].lectura).toFixed(2);
                const formula = `G(s)=\\frac{${(K * omegaN ** 2).toFixed(2)}}{s^2 + ${(2 * dseta * omegaN).toFixed(2)}\\,s + ${(omegaN ** 2).toFixed(3)}}`;

                katex.render(formula, document.getElementById("formula"));
            }

        }
        function analizarDatos() {
            var tempINI;
            var tempFIN;
            var inputFechaInicio = new Date(document.getElementById("inputFechaInicio").value + ":00Z");
            var inputTempInicio = document.getElementById("inputTempInicio").value;
            var inputFechaFin = new Date(document.getElementById("inputFechaFin").value + ":00Z");
            var inputTempFin = document.getElementById("inputTempFin").value;
            //console.log(inputFechaInicio + " " + inputFechaFin);
            //console.log(inputFechaFin + " " + inputTempFin);

            var filtrados = datos.filter(item => {
                const fechaItem = new Date(item.fecha);
                return fechaItem >= inputFechaInicio && fechaItem <= inputFechaFin;
            });

            console.log(filtrados);
            var valorE = {};
            if (filtrados.length > 0) {
                const temperaturas = filtrados.map(item => item.lectura);
                tempINI = filtrados[0].lectura;
                tempFIN = filtrados[filtrados.length - 1].lectura;
                var lecturaTAU = Math.abs(tempFIN - tempINI) * 0.63 + Math.min(tempFIN, tempINI);
                console.log("Temperatura inicial:", tempINI);
                console.log("Temperatura final:", tempFIN);
            } else {
                console.log("No hay datos en el rango seleccionado");
            }
            console.log("lecturaTAU: " + lecturaTAU)


            for (let i = 0; i < filtrados.length - 1; i++) {
                if (filtrados[i].lectura > lecturaTAU) {
                    valorE = filtrados[i];
                    break;
                }
            }
            valorE.fecha = new Date(valorE.fecha);
            console.log(valorE);

            const diffMs = valorE.fecha - inputFechaInicio;
            // Convertir a segundos
            const tau = diffMs / 1000;
            //console.log("TAU: ", tau);
            const K = (tempFIN / tempINI).toFixed(2);
            let formula = "G(s) = \\frac{" + K + "}{" + tau + " s + 1}";
            katex.render(formula, document.getElementById("formula"));
        }

        // =========================
        // GRAFICO LINEAL
        // =========================
        let miGrafica = null;


        var datos;

        async function actualizarGraficaLineal(chart) {
            document.getElementById('grafico').onclick = function (evt) {
                const points = miGrafica.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                if (points.length) {
                    const firstPoint = points[0];
                    const datasetIndex = firstPoint.datasetIndex;
                    const index = firstPoint.index;

                    const dataset = miGrafica.data.datasets[datasetIndex];
                    const historicoCompleto = dataset.historicoCompleto; // array con objetos {fecha, lectura}
                    const value = dataset.data[index];
                    const fechaCompleta = historicoCompleto[index].fecha;

                    const f = new Date(fechaCompleta);
                    const fechaInput = f.toISOString().slice(0, 16); // formato YYYY-MM-DDTHH:MM

                    if (toggleInputs) {
                        // Primer par de inputs
                        document.getElementById('inputFechaInicio').value = fechaInput;
                        document.getElementById('inputTempInicio').value = value;
                    } else {
                        // Segundo par de inputs
                        document.getElementById('inputFechaFin').value = fechaInput;
                        document.getElementById('inputTempFin').value = value;
                    }

                    // Alternar para el siguiente click
                    toggleInputs = !toggleInputs;
                }
            };

            const historico = await fetchDatos('historico');
            if (!historico) return;
            datos = historico;

            const labels = historico.map(h => formatearHora(h.fecha));
            const data = historico.map(h => h.lectura);

            if (!chart) {
                return new Chart(document.getElementById("grafico").getContext("2d"), {
                    type: "line",
                    data: {
                        labels,
                        datasets: [{
                            label: "Temp",
                            data,
                            borderColor: 'rgba(255,0,0,1)',
                            backgroundColor: 'rgba(255,0,0,0.1)',
                            fill: true,
                            tension: 0.3,
                            historicoCompleto: historico // <-- guardamos referencia
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: true },
                            tooltip: { mode: 'index', intersect: false }
                        },
                        scales: {
                            x: { display: true, title: { display: true, text: 'Hora' } },
                            y: { display: true, title: { display: true, text: '°C' } }
                        }
                    }
                });
            } else {
                chart.data.labels = labels;
                chart.data.datasets[0].data = data;
                chart.update();
                return chart;
            }
        }

        (async () => {
            miGrafica = await actualizarGraficaLineal(null);
            setInterval(() => actualizarGraficaLineal(miGrafica), 30000);
        })();
        // Asumiendo que tu Chart.js ya está inicializado como miGrafica

        let toggleInputs = true; // true = inicio, false = fin


        // =========================
        // GAUGE
        // =========================
        const canvas = document.getElementById('gauge');
        const ctx = canvas.getContext('2d');

        function drawGauge(value, min = 10, max = 70) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height;
            const radius = 100;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Fondo semicírculo
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, Math.PI, 0, false);
            ctx.lineWidth = 30;
            ctx.strokeStyle = '#444';
            ctx.stroke();

            // Porcentaje del valor
            const pct = (value - min) / (max - min);
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, Math.PI, Math.PI + Math.PI * pct, false);
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 30;
            ctx.stroke();

            // Aguja
            const angle = Math.PI + pct * Math.PI;
            const needleLength = radius - 15;
            const needleX = centerX + needleLength * Math.cos(angle);
            const needleY = centerY + needleLength * Math.sin(angle);

            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(needleX, needleY);
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#ff0000';
            ctx.stroke();

            // Texto central
            ctx.font = '20px Consolas';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText(value.toFixed(1) + ' °C', centerX, centerY - 20);
        }

        async function actualizarGauge() {
            const ultimo = await fetchDatos('ultimo');
            if (!ultimo) return;

            document.getElementById("ultimo").innerText =
                `Última temperatura: ${ultimo.lectura} °C (${formatearFecha(ultimo.fecha)})`;

            drawGauge(ultimo.lectura, 10, 70);
        }

        actualizarGauge();
        setInterval(actualizarGauge, 5000);


        // =========================
        // MQTT
        // =========================
        const MQTT_IP = <%- JSON.stringify(serverIP) %>;
        const MQTT_NAME = <%- JSON.stringify(serverName) %>;
        const MQTT_WEBSOCKET_PORT = <%= mqttPort %>;
        console.log("Broker MQTT:", MQTT_NAME, MQTT_WEBSOCKET_PORT);
        //const client = new Paho.Client(MQTT_NAME, MQTT_WEBSOCKET_PORT, "clienteWeb");
        //const client = new Paho.Client("mqtt.guardiandelfaro.es", 9001, "/mqtt", "clienteWeb")
        //var client = new Paho.MQTT.Client("mqtt.guardiandelfaro.es", 9001, "clienteWeb");
        var client = new Paho.MQTT.Client(MQTT_NAME, MQTT_WEBSOCKET_PORT, "clienteWeb");
        client.connect({
            useSSL: true,
            onSuccess: () => {
                console.log("Conectado WebSocket");
                document.getElementById("btn1Encender").addEventListener("click", () => {
                    client.send("wemos/salida1", "ON");
                    console.log("Enviando encendido 1");

                });
                document.getElementById("btn1Apagar").addEventListener("click", () => {
                    client.send("wemos/salida1", "OFF");
                    console.log("Enviando apagado 1");
                });
                document.getElementById("btnEncender2").addEventListener("click", () => {
                    client.send("wemos/salida2", "ON");
                    console.log("Enviando encendido 2");

                });
                document.getElementById("btnApagar2").addEventListener("click", () => {
                    client.send("wemos/salida2", "OFF");
                    console.log("Enviando apagado 2");
                });
            },
            onFailure: e => console.error("Error MQTT", e)
        });

    </script>
</body>

</html>